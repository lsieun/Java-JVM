# Class Member

<!-- TOC -->

- [1. 静态字段](#1-静态字段)
    - [1.1. 获取静态字段](#11-获取静态字段)
    - [1.2. 设置静态字段](#12-设置静态字段)
- [2. 非静态字段](#2-非静态字段)
    - [2.1. 获取非静态字段](#21-获取非静态字段)
    - [2.2. 设置非静态字段](#22-设置非静态字段)
- [3. 方法调用](#3-方法调用)
    - [3.1. 静态方法调用](#31-静态方法调用)
- [4. 非静态方法调用](#4-非静态方法调用)
    - [4.1. 接口方法调用](#41-接口方法调用)
- [5. More](#5-more)

<!-- /TOC -->

可以写出来的方法有许多种，我们

public/protected/private
constructor
staticMethod
InterfaceMethod
parentMethod

## 1. 静态字段

### 1.1. 获取静态字段

学习目标：

- `getstatic`: Get `static` field from class

示例代码：

```java
public class HelloWorld {
    public static int intValue = 5;

    public void testSimple() {
        int i = HelloWorld.intValue;
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_Fieldref {Value='lsieun/sample/HelloWorld.intValue:I', HexCode='0900030014'}
    ......

code='B200023CB1'
    0: getstatic 2     // B20002
    3: istore_1        // 3C
    4: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       5  this:Llsieun/sample/HelloWorld;
    1         4       1  i:I
```

### 1.2. 设置静态字段

学习目标：

- `putstatic`: Set `static` field in class

示例代码：

```java
public class HelloWorld {
    public static int intValue = 5;

    public void testSimple() {
        HelloWorld.intValue = 3;
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_Fieldref {Value='lsieun/sample/HelloWorld.intValue:I', HexCode='0900030013'}
    ......

code='06B30002B1'
    0: iconst_3        // 06
    1: putstatic 2     // B30002
    4: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       5  this:Llsieun/sample/HelloWorld;
```

## 2. 非静态字段

### 2.1. 获取非静态字段

学习目标：

- `getfield`: Fetch field from object

示例代码：

```java
public class HelloWorld {
    public int intValue;

    public void testSimple() {
        int i = this.intValue;
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_Fieldref {Value='lsieun/sample/HelloWorld.intValue:I', HexCode='0900030013'}
    ......

code='2AB400023CB1'
    0: aload_0         // 2A
    1: getfield 2      // B40002
    4: istore_1        // 3C
    5: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       6  this:Llsieun/sample/HelloWorld;
    1         5       1  i:I
```

### 2.2. 设置非静态字段

学习目标：

- `putfield`: Set field in object

示例代码：

```java
public class HelloWorld {
    public int intValue;

    public void testSimple() {
        this.intValue = 3;
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_Fieldref {Value='lsieun/sample/HelloWorld.intValue:I', HexCode='0900030012'}

code='2A06B50002B1'
    0: aload_0         // 2A
    1: iconst_3        // 06
    2: putfield 2      // B50002
    5: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       6  this:Llsieun/sample/HelloWorld;
```

## 3. 方法调用

### 3.1. 静态方法调用

学习目标：

- `invokestatic`: Invoke a class (`static`) method

示例代码：

```java
public class HelloWorld {
    public void testSimple() {
        int i = Math.abs(-1);
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_Methodref {Value='java/lang/Math.abs:(I)I', HexCode='0A00120013'}
    ......

code='02B800023CB1'
    0: iconst_m1       // 02
    1: invokestatic 2  // B80002
    4: istore_1        // 3C
    5: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       6  this:Llsieun/sample/HelloWorld;
    1         5       1  i:I
```

## 4. 非静态方法调用

学习目标：

- `invokevirtual`: Invoke instance method; dispatch based on class

示例代码：

```java
public class HelloWorld {
    public void testSimple() {
        String str = this.toString();
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_Methodref {Value='java/lang/Object.toString:()Ljava/lang/String;', HexCode='0A00040012'}
    ......

code='2AB600024CB1'
    0: aload_0         // 2A
    1: invokevirtual 2 // B60002
    4: astore_1        // 4C
    5: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       6  this:Llsieun/sample/HelloWorld;
    1         5       1  str:Ljava/lang/String;
```

### 4.1. 接口方法调用

学习目标：

- `invokeinterface`: Invoke interface method

示例代码：

```java
public class HelloWorld {
    public void testSimple() {
        Runnable instance = null;
        instance.run();
    }
}
```

输出结果：

```txt
ConstantPool {
    |002| CONSTANT_InterfaceMethodref {Value='java/lang/Runnable.run:()V', HexCode='0B00120013'}
    ......

code='014C2BB900020100B1'
    0: aconst_null     // 01
    1: astore_1        // 4C
    2: aload_1         // 2B
    3: invokeinterface 2 1 0// B900020100
    8: return          // B1


LocalVariableTable:
index  start_pc  length  name_and_type
    0         0       9  this:Llsieun/sample/HelloWorld;
    1         2       7  instance:Ljava/lang/Runnable;
```

## 5. More

To allow you to write the code in a convenient **object-oriented syntax** in which you “send a message to an object,” the compiler does some undercover work for you. There’s a secret first argument passed to the method `peel()`, and that argument is the reference to the object that’s being manipulated. So the two method calls become something like:

```java
Banana.peel(a, 1);
Banana.peel(b, 2);
```

Suppose you’re inside a method and you’d like to get the reference to the **current object**. Since that **reference** is passed secretly by the compiler, there’s no identifier for it. However, for this purpose there’s a keyword: `this`. The `this` keyword — which can be used only inside a non-static method — produces the reference to the object that the method has been called for. You can treat **the reference** just like any other object reference. Keep in mind that if you’re calling a method of your class from within another method of your class, you don’t need to use `this`. You simply call the method. The current `this` reference is automatically used for the other method. Thus you can say:

```java
//: initialization/Apricot.java
public class Apricot {
    void pick() { /* ... */ }
    void pit() { pick(); /* ... */ }
} ///:~
```

Some people will obsessively(着迷一般地) put `this` in front of every **method call** and **field** reference, arguing that it makes it “clearer and more explicit.” **Don’t do it**. There’s a reason that we use high-level languages: They do things for us. If you put `this` in when it’s not necessary, you will confuse and annoy everyone who reads your code, since all the rest of the code they’ve read won’t use `this` everywhere. People expect `this` to be used only when it is necessary. Following a consistent and straightforward coding style saves time and money. -- 《Think in Java》



